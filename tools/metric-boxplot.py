#!/usr/bin/python
'''
   Usage: ./metric-boxplot.py <out-put-dir>
   Example usage: ./metric-boxplot.py /vagrant/boxplots/

   FIXME: Add elaborate notes explainining what is happening here !!
'''

import argparse
import csv
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
import sys
from metric_query import get_data_set
from collections import OrderedDict

'''
 A flag that controls we're running in development mode or regular mode.
 In development mode, we use hardcoded test data and do not accept input
 file as a command line argument.
'''
TOOL_IN_DEVELOPMENT_MODE = False

parser = argparse.ArgumentParser(description="Tool to generate box plot for" \
   " all 8 channels of extruder machine")
if not TOOL_IN_DEVELOPMENT_MODE:
  parser.add_argument("input_file", help=".csv file containing the input data. Example data file: https://docs.google.com/spreadsheets/d/1a1GZeSylfCLVpj_lTlNcSvNi1Cz1qwTYQkfh2wGA5PQ/edit#gid=0")
parser.add_argument("output_dir", help="Location to save the generated boxplots")
parser.add_argument("--report_board_aggr", help="For a given input signal, we record and analyse separately for each channel. However its useful to get a collective sense across the board. This option enables generation of the combination of data across all channels for a given input signal. Look for the metric_id 'Combined' in the report. Note that 'Combined' is an articificial construct for analysis purposes only. Use like this: --report_board_aggr=True", type=bool, default=False)
args = parser.parse_args()

def generate_filename(timewindow_id):
  return timewindow_id.replace(" ", "_")

'''
  The following 2 pieces of information (metric_list and hardware_channel_id)
  should be obtained from the data model via APIs. For now hardcoding it here.

  metric_list and hardware_channel_id server quite different purposes.

  metric_list:
   Needed to construct query URL for retrieving information from TSDB.

  hardware_channel_id:
   Needs to be printed in the report generated by this tool. That channel number
   is crucial information for the reader of that report.

  Source for metric_list & hardware_channel_id below is the 65mm & 90mm
  extruder machine configs from here:
  https://github.com/argusiot/authored-source-code/tree/master/deployments/customer_sites/pp-lab/input
'''
hardware_channel_id = [8, 7, 6, 5, 4, 3, 2, 1]
metric_list = ["raw_melt_temperature", "raw_melt_pressure", "raw_screw_speed", \
               "raw_line_speed", "raw_barrel_temperature_1", \
               "raw_barrel_temperature_2", "raw_machine_powerOn_state", \
               "raw_wire_output_diameter"] 
if args.report_board_aggr:
  hardware_channel_id.append('C')


# For now, we hardcode the URL template. Ideally, we should not have to do this.
# This should be an API for us to get the data from.
url_template="http://34.221.154.248:4242/api/query?start=%s&end=%s&m=none:machine.sensor.%s{machine_name=%s}"

# Format:
# (label_str, metric_id, hw_chan_id, total_cnt, Min, Max, Mean, StdDev, %age-std-dev)
statistics_results = []

# Build a dictionary from the input CSV file. The dictionary should look like
# test_data_src.
# CSV schema:
# ['Board', 'Power supply', 'Sampling resolution', 'Input signal', 'Start time', 'End time', 'Machine', 'Manually audited', 'Start time (derived)', 'End time (derived)', 'Query URL']
label_format="Label format: <ADC board> <power_src> <sampling resolution> <input_signal>"
def build_test_data_src_from_csv(input_file):
  test_data = OrderedDict()
  with open(input_file) as csvfile:
      first_line = True
      reader = csv.reader(csvfile, delimiter=',')
      for line in reader:
        if first_line:  # skip the first line
          first_line = False
          continue

        board, power_supply, sampling_res, input_signal, \
        start_time_msec, end_time_msec, machine, audited, ignore1, \
        ignore2, ignore3 = line

        # The data_label is formatted per label_format above !
        data_label = "%s %s %s %s" % (board, power_supply, sampling_res, \
                                      input_signal)
        if start_time_msec == "" or \
           end_time_msec == "" or \
           machine == "":
          print("Skipping %s ...incomplete information !"  % data_label)
          continue

        # Add record into test_data{}
        test_data[data_label] = ([int(start_time_msec), int(end_time_msec)], \
                                  machine)
  return test_data

def get_hardcoded_test_data():
  test_data = OrderedDict()
  test_data["Current data on 65mm"] = (["2m-ago", "1m-ago"], "65mm_extruder")
  return test_data

# Helper routine to compute stats and record the outcome into some housekeeping
# objects.
def record_data(data_label, sorted_data_values, metric_id, hw_chan_id, \
                statistics_results, box_plot_data):
  # Calculate statistics for the data received and store in the stats result.
  np_stats_calculator = np.array([sorted_data_values])
  statistics_results.append( \
    (data_label, metric_id, hw_chan_id, len(sorted_data_values), \
     sorted_data_values[0], sorted_data_values[len(sorted_data_values) - 1], \
     np.mean(np_stats_calculator), np.std(np_stats_calculator), \
     (100.0 * np.std(np_stats_calculator)) / np.mean(np_stats_calculator)))

  # Collect this data for generating the box plot.
  box_plot_data.append(sorted_data_values)


def analyse_data():
  # Populate test_data_src from CSV file input.
  test_data_src = None
  if TOOL_IN_DEVELOPMENT_MODE:
    test_data_src = get_hardcoded_test_data()
  else:
    test_data_src = build_test_data_src_from_csv(args.input_file)

  for data_label, (time_window, machine_name) in test_data_src.items():
    
    print("Processing Label - %s" % data_label)
    if len(time_window) > 0:
      print("Time window: (%s, %s)" % (time_window[0], time_window[1]))
    else:
      print("Skipping\n")
      continue

    # A place to combine the datapoints from all channels into 1.
    # This feature attempts to allow us to arrive at board level statistics
    # for a given signal level.
    combined_dps = []

    # A place to collect the results returned for each metric query.
    box_plot_data = []

    for idx in range(len(metric_list)):
      url = url_template % (time_window[0], time_window[1], \
                            metric_list[idx], machine_name)
      print(url)

      # Extract list of values from the returned dict and sort the list. We sort
      # here because we want to easily get min/max (for reporting purposes).
      # FIXME: Once we move to Python3 we can use the statistics package and wont
      # need to do these silly things like sort to get min/max etc.
      sorted_data_values = get_data_set(url).values()
      sorted_data_values.sort()

      combined_dps.extend(sorted_data_values)  # collect dps for aggregate stats.

      record_data(data_label, sorted_data_values, metric_list[idx], \
                  hardware_channel_id[idx], statistics_results,box_plot_data)

    # Append data for combined stats for that signal level.
    if args.report_board_aggr:
      record_data(data_label, combined_dps, "Combined", 'C', statistics_results, \
                  box_plot_data)

    fig1, ax1 = plt.subplots()
    ax1.set_title(data_label)
    ax1.boxplot(box_plot_data, labels=hardware_channel_id, showmeans=True, showfliers=True)
    plt.ylabel('Value read on channel')
    plt.xlabel('Channel number (on ADC board)')
    plt.grid(True)

    # Save plot to file
    fq_file_path = "%s/%s" % (args.output_dir, generate_filename(data_label))
    plt.savefig(fq_file_path)
    print("\n")


analyse_data() # Begin analysis !!

print("See boxplots generated here: %s\n" % args.output_dir)

header_row = "%-25s %25s %7s %15s %8s %8s %8s %8s %10s" % \
            ("Label", "Metric", "HW chan", "DataPt", "Min", "Max", "Mean", "StdDev", \
             "%Dev.")
print("%s\n%s" % (label_format, header_row))
old_label = None
for result in statistics_results:
  label, metric, hw_chan, dp_count, min_val, max_val, mean, stddev, percent_dev = result

  if old_label != label:  # Print a separator line on each label transition.
    print("%-25s %s" % (label, '-'*100))
    old_label = label

  print("%-25s %25s %7s %15d %8d %8d %8.1f %8.02f %8.02f%%" % \
        (label, metric, str(hw_chan), dp_count, min_val, max_val, mean, stddev, percent_dev))
